<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mesh Object &#8212; PyLaGriT 0.0.0 documentation</title>
    
    <link rel="stylesheet" href="static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="PyLaGriT 0.0.0 documentation" href="index.html" />
    <link rel="up" title="Class Documentation" href="autodoc.html" />
    <link rel="next" title="Mesh Object" href="autodoc_pset.html" />
    <link rel="prev" title="PyLaGriT" href="autodoc_pylagrit.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-pylagrit">
<span id="mesh-object"></span><h1>Mesh Object<a class="headerlink" href="#module-pylagrit" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pylagrit.MO">
<em class="property">class </em><code class="descclassname">pylagrit.</code><code class="descname">MO</code><span class="sig-paren">(</span><em>name</em>, <em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO" title="Permalink to this definition">¶</a></dt>
<dd><p>Mesh object class</p>
<dl class="method">
<dt id="pylagrit.MO.addatt">
<code class="descname">addatt</code><span class="sig-paren">(</span><em>attname</em>, <em>keyword=None</em>, <em>type='VDOUBLE'</em>, <em>rank='scalar'</em>, <em>length='nnodes'</em>, <em>interpolate='linear'</em>, <em>persistence='permanent'</em>, <em>ioflag=''</em>, <em>value=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.addatt" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of attributes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attnames</strong> (<em>str</em>) &#8211; Attribute name to add</li>
<li><strong>keyword</strong> &#8211; Keyword used by lagrit for specific attributes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.addatt_voronoi_volume">
<code class="descname">addatt_voronoi_volume</code><span class="sig-paren">(</span><em>name='voronoi_volume'</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.addatt_voronoi_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Add voronoi volume attribute to mesh object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<em>str</em>) &#8211; name of attribute in LaGriT</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><em>option1='delaunay'</em>, <em>option2=None</em>, <em>stride=None</em>, <em>big_tet_coords=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the nodes into a Delaunay tetrahedral or triangle grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>option1</strong> &#8211; type of connect: delaunay, noadd, or check_interface</li>
<li><strong>option2</strong> &#8211; type of connect: noadd, or check_interface</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.connect_check_interface">
<code class="descname">connect_check_interface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.connect_check_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the nodes into a Delaunay tetrahedral or triangle grid
exhaustively checking that no edges of the mesh cross a material
boundary.</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.connect_delaunay">
<code class="descname">connect_delaunay</code><span class="sig-paren">(</span><em>option2=None</em>, <em>stride=None</em>, <em>big_tet_coords=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.connect_delaunay" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the nodes into a Delaunay tetrahedral or triangle grid without adding nodes.</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.connect_noadd">
<code class="descname">connect_noadd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.connect_noadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the nodes into a Delaunay tetrahedral or triangle grid without adding nodes.</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy mesh object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.copyatt">
<code class="descname">copyatt</code><span class="sig-paren">(</span><em>attname_src</em>, <em>attname_sink=None</em>, <em>mo_src=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.copyatt" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of attributes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attname_src</strong> (<em>str</em>) &#8211; Name of attribute to copy</li>
<li><strong>attname_sink</strong> (<em>str</em>) &#8211; Name of sink attribute</li>
<li><strong>mo_src</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; Name of source mesh object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.copypts">
<code class="descname">copypts</code><span class="sig-paren">(</span><em>elem_type='tet'</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.copypts" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy points from mesh object to new mesh object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Name to use within lagrit for the created mesh object</li>
<li><strong>mesh_type</strong> (<em>str</em>) &#8211; Mesh type for new mesh</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mesh object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.create_boundary_facesets">
<code class="descname">create_boundary_facesets</code><span class="sig-paren">(</span><em>stacked_layers=False</em>, <em>base_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.create_boundary_facesets" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates facesets for each boundary and writes associated avs faceset file
:arg base_name: base name of faceset files
:type base_name: str
:arg stacked_layers: if mesh is created by stack_layers, user layertyp attr to determine top and bottom
:type stacked_layers: bool
:arg reorder_on_meds: reorder nodes on cell medians, usually needed for exodus file
:type reorder_on_meds: bool
:returns: Dictionary of facesets</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.createpts">
<code class="descname">createpts</code><span class="sig-paren">(</span><em>crd</em>, <em>npts</em>, <em>mins</em>, <em>maxs</em>, <em>rz_switch=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_value=(1</em>, <em>1</em>, <em>1)</em>, <em>connect=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.createpts" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Connect Points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>crd</strong> (<em>str</em>) &#8211; Coordinate type of either &#8216;xyz&#8217; (cartesian coordinates), 
&#8216;rtz&#8217; (cylindrical coordinates), or 
&#8216;rtp&#8217; (spherical coordinates).</li>
<li><strong>npts</strong> (<em>tuple(int)</em>) &#8211; The number of points to create in line</li>
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; The starting value for each dimension.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; The ending value for each dimension.</li>
<li><strong>rz_switch</strong> (<em>tuple(int, int, int)</em>) &#8211; Determines true or false (1 or 0) for using ratio zoning values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.createpts_brick">
<code class="descname">createpts_brick</code><span class="sig-paren">(</span><em>crd</em>, <em>npts</em>, <em>mins</em>, <em>maxs</em>, <em>ctr=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_switch=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_vls=(1</em>, <em>1</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.createpts_brick" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Connect Points</p>
<p>Creates a grid of points in the mesh object and connects them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>crd</strong> (<em>str</em>) &#8211; Coordinate type of either &#8216;xyz&#8217; (cartesian coordinates), 
&#8216;rtz&#8217; (cylindrical coordinates), or 
&#8216;rtp&#8217; (spherical coordinates).</li>
<li><strong>npts</strong> (<em>tuple(int, int, int)</em>) &#8211; The number of points to create in each dimension.</li>
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; The starting value for each dimension.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; The ending value for each dimension.</li>
<li><strong>ctr</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines the center of each cell. For 0, points are placed in
the middle of each cell. For 1, points are placed at the 
edge of each cell.</li>
<li><strong>rz_switch</strong> (<em>tuple(int, int, int)</em>) &#8211; Determines true or false (1 or 0) for using ratio 
zmoning values.</li>
<li><strong>rz_vls</strong> (<em>tuple(int, int, int)</em>) &#8211; Ratio zoning values. Each point will be multiplied by
a scale of the value for that dimension.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.createpts_brick_rtp">
<code class="descname">createpts_brick_rtp</code><span class="sig-paren">(</span><em>npts</em>, <em>mins</em>, <em>maxs</em>, <em>ctr=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_switch=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_vls=(1</em>, <em>1</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.createpts_brick_rtp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and connect spherical coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.createpts_brick_rtz">
<code class="descname">createpts_brick_rtz</code><span class="sig-paren">(</span><em>npts</em>, <em>mins</em>, <em>maxs</em>, <em>ctr=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_switch=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_vls=(1</em>, <em>1</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.createpts_brick_rtz" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and connect cylindrical coordinate points.</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.createpts_brick_xyz">
<code class="descname">createpts_brick_xyz</code><span class="sig-paren">(</span><em>npts</em>, <em>mins</em>, <em>maxs</em>, <em>ctr=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_switch=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_vls=(1</em>, <em>1</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.createpts_brick_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and connect Cartesian coordinate points.</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.createpts_dxyz">
<code class="descname">createpts_dxyz</code><span class="sig-paren">(</span><em>dxyz</em>, <em>mins</em>, <em>maxs</em>, <em>clip='under'</em>, <em>hard_bound='min'</em>, <em>rz_switch=(1</em>, <em>1</em>, <em>1)</em>, <em>rz_value=(1</em>, <em>1</em>, <em>1)</em>, <em>connect=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.createpts_dxyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Connect Points to create an orthogonal hexahedral mesh. The
vertex spacing is based on dxyz and the mins and maxs specified. mins
(default, see hard_bound option) or maxs will be adhered to, while maxs
(default) or mins will be modified based on the clip option to be
truncated at the nearest value &#8216;under&#8217; (default) or &#8216;over&#8217; the range
maxs-mins. clip and hard_bound options can be mixed by specifying tuples
(see description below).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dxyz</strong> (<em>tuple(float,float,float)</em>) &#8211; The spacing between points in x, y, and z directions</li>
<li><strong>mins</strong> (<em>tuple(float,float,float)</em>) &#8211; The starting value for each dimension.</li>
<li><strong>maxs</strong> (<em>tuple(float,float,float)</em>) &#8211; The ending value for each dimension.</li>
<li><strong>clip</strong> (<em>string or tuple(string,string,string)</em>) &#8211; How to handle bounds if range does not divide by dxyz, either clip &#8216;under&#8217; or &#8216;over&#8217; range</li>
<li><strong>hard_bound</strong> (<em>string or tuple(string,string,string)</em>) &#8211; Whether to use the &#8220;min&#8221; or &#8220;max&#8221; as the hard constraint on dimension</li>
<li><strong>rz_switch</strong> (<em>tuple(int, int, int)</em>) &#8211; Determines true or false (1 or 0) for using ratio zoning values.</li>
<li><strong>connect</strong> (<em>boolean</em>) &#8211; Whether or not to connect points</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.createpts_line">
<code class="descname">createpts_line</code><span class="sig-paren">(</span><em>npts</em>, <em>mins</em>, <em>maxs</em>, <em>rz_switch=(1</em>, <em>1</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.createpts_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Connect Points in a line</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>npts</strong> (<em>int</em>) &#8211; The number of points to create in line</li>
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; The starting value for each dimension.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; The ending value for each dimension.</li>
<li><strong>rz_switch</strong> (<em>tuple(int, int, int)</em>) &#8211; Determines true or false (1 or 0) for using ratio zoning values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.delatt">
<code class="descname">delatt</code><span class="sig-paren">(</span><em>attnames</em>, <em>force=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.delatt" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a list of attributes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attnames</strong> (<em>str or lst(str)</em>) &#8211; Attribute names to delete</li>
<li><strong>force</strong> (<em>bool</em>) &#8211; If true, delete even if the attribute permanent persistance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.dump_ats_xml">
<code class="descname">dump_ats_xml</code><span class="sig-paren">(</span><em>filename</em>, <em>meshfilename</em>, <em>matnames={}</em>, <em>facenames={}</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.dump_ats_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>Write ats style xml file with regions
:param filename: Name of xml to write
:type filename: string
:param meshfilename: Name of exodus file to use in xml
:type meshfilename: string
:param matnames: Dictionary of region names keyed by exodus material number
:type matnames: dict
:param facenames: Dictionary of faceset names keyed by exodus faceset number
:type facenames: dict</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.dump_avs2">
<code class="descname">dump_avs2</code><span class="sig-paren">(</span><em>filename</em>, <em>points=True</em>, <em>elements=True</em>, <em>node_attr=True</em>, <em>element_attr=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.dump_avs2" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump avs file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; Name of avs file</li>
<li><strong>points</strong> (<em>bool</em>) &#8211; Output point coordinates</li>
<li><strong>elements</strong> (<em>bool</em>) &#8211; Output connectivity</li>
<li><strong>node_attr</strong> (<em>bool</em>) &#8211; Output node attributes</li>
<li><strong>element_attr</strong> (<em>bool</em>) &#8211; Output element attributes</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.dump_exo">
<code class="descname">dump_exo</code><span class="sig-paren">(</span><em>filename</em>, <em>psets=False</em>, <em>eltsets=False</em>, <em>facesets=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.dump_exo" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump exo file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>str</em>) &#8211; Name of exo file</li>
<li><strong>psets</strong> (<em>bool</em>) &#8211; Boolean indicating that exodus will only include psets</li>
<li><strong>eltsets</strong> (<em>bool</em>) &#8211; Boolean indicating that exodus will only include element sets</li>
<li><strong>facesets</strong> (<em>lst(FaceSet)</em>) &#8211; Array of FaceSet objects</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylagrit</span> <span class="k">import</span> <span class="n">PyLaGriT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">PyLaGriT</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">createpts_xyz</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),</span><span class="n">rz_switch</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">status</span> <span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">status</span> <span class="p">(</span><span class="n">brief</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">create_boundary_facesets</span><span class="p">(</span><span class="n">base_name</span><span class="o">=</span><span class="s1">&#39;faceset_bounds&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">dump_exo</span><span class="p">(</span><span class="s1">&#39;cube.exo&#39;</span><span class="p">,</span><span class="n">facesets</span><span class="o">=</span><span class="n">fs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.dump_pset">
<code class="descname">dump_pset</code><span class="sig-paren">(</span><em>filerootname</em>, <em>zonetype='zone'</em>, <em>pset=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.dump_pset" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump zone file of psets
:arg filerootname: rootname of files to create, pset name will be added to name
:type filerootname: string
:arg zonetype: Type of zone file to dump, &#8216;zone&#8217; or &#8216;zonn&#8217;
:type zonetype: string
:arg pset: list of psets to dump, all psets dumped if empty list
:type pset: list[strings]</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.eltset_bool">
<code class="descname">eltset_bool</code><span class="sig-paren">(</span><em>eset_list</em>, <em>boolstr='union'</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.eltset_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Create element set from boolean operation of set of element sets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>eset_list</strong> (<em>lst(PyLaGriT element set)</em>) &#8211; List of elements to perform boolean operation on</li>
<li><strong>boolstr</strong> (<em>str</em>) &#8211; type of boolean operation to perform on element sets, one of [union,inter,not]</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the EltSet within LaGriT</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">PyLaGriT element set object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.eltset_object">
<code class="descname">eltset_object</code><span class="sig-paren">(</span><em>mo</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.eltset_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Create element set from the intersecting elements with another mesh object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.extrude">
<code class="descname">extrude</code><span class="sig-paren">(</span><em>offset</em>, <em>offset_type='const'</em>, <em>return_type='volume'</em>, <em>direction=[]</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.extrude" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude mesh object to new mesh object
This command takes the current mesh object (topologically 1d or 2d mesh (a line, a set of line 
segments, or a planar or non-planar surface)) and extrudes it into three 
dimensions along either the normal to the curve or surface (default), 
along a user defined vector, or to a set of points that the user has specified.
If the extrusion was along the normal of the surface or along a user 
defined vector, the command can optionally find the external surface of 
the volume created and return that to the user.
Refer to <a class="reference external" href="http://lagrit.lanl.gov/docs/commands/extrude.html">http://lagrit.lanl.gov/docs/commands/extrude.html</a> for more details on arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Name to use within lagrit for the created mesh object</li>
<li><strong>offset</strong> (<em>float</em>) &#8211; Distance to extrude</li>
<li><strong>offset_type</strong> (<em>str</em>) &#8211; either const or min (interp will be handled in the PSET class in the future)</li>
<li><strong>return_type</strong> (<em>str</em>) &#8211; either volume for entire mesh or bubble for just the external surface</li>
<li><strong>direction</strong> (<em>lst[float,float,float]</em>) &#8211; Direction to extrude in, defaults to normal of the object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mesh object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid">
<code class="descname">grid2grid</code><span class="sig-paren">(</span><em>ioption</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a mesh with one element type to a mesh with another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ioption</strong> &#8211; type of conversion:
quadtotri2   quad to 2 triangles, no new points. 
prismtotet3   prism to 3 tets, no new points. 
quadtotri4   quad to 4 triangles, with one new point. 
pyrtotet4   pyramid to 4 tets, with one new point. 
hextotet5   hex to 5 tets, no new points. 
hextotet6   hex to 6 tets, no new points. 
prismtotet14   prism to 14 tets, four new points (1 + 3 faces). 
prismtotet18   prism to 18 tets, six new points (1 + 5 faces). 
hextotet24   hex to 24 tets, seven new points (1 + 6 faces). 
tree_to_fe   quadtree or octree grid to grid with no parent-type elements.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; Internal Lagrit name of new mesh object, automatically created if None</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_hextotet24">
<code class="descname">grid2grid_hextotet24</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_hextotet24" title="Permalink to this definition">¶</a></dt>
<dd><p>Hex to 24 tets, seven new points (1 + 6 faces)
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_hextotet5">
<code class="descname">grid2grid_hextotet5</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_hextotet5" title="Permalink to this definition">¶</a></dt>
<dd><p>Hex to 5 tets, no new points
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_hextotet6">
<code class="descname">grid2grid_hextotet6</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_hextotet6" title="Permalink to this definition">¶</a></dt>
<dd><p>Hex to 6 tets, no new points
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_prismtotet14">
<code class="descname">grid2grid_prismtotet14</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_prismtotet14" title="Permalink to this definition">¶</a></dt>
<dd><p>Prism to 14 tets, four new points (1 + 3 faces)
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_prismtotet18">
<code class="descname">grid2grid_prismtotet18</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_prismtotet18" title="Permalink to this definition">¶</a></dt>
<dd><p>Prism to 18 tets, four new points (1 + 3 faces)
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_prismtotet3">
<code class="descname">grid2grid_prismtotet3</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_prismtotet3" title="Permalink to this definition">¶</a></dt>
<dd><p>Quad to 2 triangles, no new points. 
Prism to 3 tets, no new points. 
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_pyrtotet4">
<code class="descname">grid2grid_pyrtotet4</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_pyrtotet4" title="Permalink to this definition">¶</a></dt>
<dd><p>Pyramid to 4 tets, with one new point
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_quadtotri2">
<code class="descname">grid2grid_quadtotri2</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_quadtotri2" title="Permalink to this definition">¶</a></dt>
<dd><p>Quad to 2 triangles, no new points. 
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_quadtotri4">
<code class="descname">grid2grid_quadtotri4</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_quadtotri4" title="Permalink to this definition">¶</a></dt>
<dd><p>Quad to 4 triangles, with one new point
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.grid2grid_tree_to_fe">
<code class="descname">grid2grid_tree_to_fe</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.grid2grid_tree_to_fe" title="Permalink to this definition">¶</a></dt>
<dd><p>Quadtree or octree grid to grid with no parent-type elements. 
:arg name: Internal Lagrit name of new mesh object, automatically created if None
:type name: str</p>
<p>Returns MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.interpolate">
<code class="descname">interpolate</code><span class="sig-paren">(</span><em>method, attsink, cmosrc, attsrc, stride=[1, 0, 0], tie_option=None, flag_option=None, keep_option=None, interp_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate values from attribute attsrc from mesh object cmosrc to current mesh object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.intersect_elements">
<code class="descname">intersect_elements</code><span class="sig-paren">(</span><em>mo</em>, <em>attr_name='attr00'</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.intersect_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This command takes two meshes and creates an element-based attribute in mesh1 
that contains the number of elements in mesh2 that intersected the respective 
element in mesh1. We define intersection as two elements sharing any common point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mo</strong> (<em>PyLaGriT mesh object</em>) &#8211; Mesh object to intersect with current mesh object to determine where to refine</li>
<li><strong>attr_name</strong> (<em>str</em>) &#8211; Name to give created attribute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">attr_name</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_attribute">
<code class="descname">pset_attribute</code><span class="sig-paren">(</span><em>attribute</em>, <em>value</em>, <em>comparison='eq'</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Define PSet by attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attribute</strong> (<em>str</em>) &#8211; Nodes defined by attribute ID.</li>
<li><strong>value</strong> (<em>integer</em>) &#8211; attribute ID value.</li>
<li><strong>comparison</strong> (<em>can use default without specifiy anything, or list[lt|le|gt|ge|eq|ne]</em>) &#8211; attribute comparison, default is eq.</li>
<li><strong>stride</strong> (<em>list[int, int, int]</em>) &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the PSet created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: PSet object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_bool">
<code class="descname">pset_bool</code><span class="sig-paren">(</span><em>pset_list</em>, <em>boolean='union'</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Return PSet from boolean operation on list of psets</p>
<p>Defines and returns a PSet from points that are not inside the PSet, ps.</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_geom">
<code class="descname">pset_geom</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em>, <em>ctr=(0</em>, <em>0</em>, <em>0)</em>, <em>geom='xyz'</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Define PSet by Geometry</p>
<p>Selects points from geomoetry specified by string geom and returns a 
PSet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate of one of the shape&#8217;s defining points.
xyz (Cartesian):   (x1, y1, z1); 
rtz (Cylindrical): (radius1, theta1, z1);
rtp (Spherical):   (radius1, theta1, phi1);</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate of one of the shape&#8217;s defining points.
xyz (Cartesian):   (x2, y2, z2); 
rtz (Cylindrical): (radius2, theta2, z2);
rtp (Spherical):   (radius2, theta2, phi2);</li>
<li><strong>ctr</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate of the relative center.</li>
<li><strong>geom</strong> (<em>str</em>) &#8211; Type of geometric shape: &#8216;xyz&#8217; (spherical), 
&#8216;rtz&#8217; (cylindrical), &#8216;rtp&#8217; (spherical)</li>
<li><strong>stride</strong> (<em>list[int, int, int]</em>) &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the PSet created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: PSet object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_geom_rtp">
<code class="descname">pset_geom_rtp</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em>, <em>ctr=(0</em>, <em>0</em>, <em>0)</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_geom_rtp" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms a pset of nodes within the sphere, sperical shell or sperical section 
given by radius1 to radius2, and angles theta1 to theta2 (0 - 180) and angles 
phi1 to phi2 (0 - 360).
Refer to <a class="reference external" href="http://lagrit.lanl.gov/docs/conventions.html">http://lagrit.lanl.gov/docs/conventions.html</a> for an explanation of angles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius1, theta1, and phi1.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius2, theta2, and phi2.</li>
<li><strong>stride</strong> (<em>list[int, int, int]</em>) &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the PSet created.</li>
<li><strong>ctr</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate of the relative center.</li>
<li><strong>stride</strong> &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> &#8211; The name to be assigned to the PSet created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: PSet object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_geom_rtz">
<code class="descname">pset_geom_rtz</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em>, <em>ctr=(0</em>, <em>0</em>, <em>0)</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_geom_rtz" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms a pset of nodes within the cylinder or cylindrical shell section 
given by radius1 to radius2, and angles theta1 to theta2 and height z1 to z2.
Refer to <a class="reference external" href="http://lagrit.lanl.gov/docs/conventions.html">http://lagrit.lanl.gov/docs/conventions.html</a> for an explanation of angles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius1, theta1, and z1.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius2, theta2, and z2.</li>
<li><strong>stride</strong> (<em>list[int, int, int]</em>) &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the PSet created.</li>
<li><strong>ctr</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate of the relative center.</li>
<li><strong>stride</strong> &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> &#8211; The name to be assigned to the PSet created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: PSet object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_geom_xyz">
<code class="descname">pset_geom_xyz</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em>, <em>ctr=(0</em>, <em>0</em>, <em>0)</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_geom_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Define PSet by Tetrahedral Geometry</p>
<p>Selects points from a Tetrahedral region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate point of 1 of the tetrahedral&#8217;s corners.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate point of 1 of the tetrahedral&#8217;s corners.</li>
<li><strong>ctr</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate of the relative center.</li>
<li><strong>stride</strong> (<em>list[int, int, int]</em>) &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the PSet created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: PSet object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_region">
<code class="descname">pset_region</code><span class="sig-paren">(</span><em>region</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Define PSet by region</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>region</strong> &#8211; region to create pset</li>
<li><strong>stride</strong> (<em>list[int, int, int]</em>) &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the PSet created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: PSet object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.pset_surface">
<code class="descname">pset_surface</code><span class="sig-paren">(</span><em>surface</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.pset_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Define PSet by surface</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>surface</strong> &#8211; surface to create pset</li>
<li><strong>stride</strong> (<em>list[int, int, int]</em>) &#8211; Nodes defined by ifirst, ilast, and istride.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; The name to be assigned to the PSet created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: PSet object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.refine_to_object">
<code class="descname">refine_to_object</code><span class="sig-paren">(</span><em>mo</em>, <em>level=None</em>, <em>imt=None</em>, <em>prd_choice=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.refine_to_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine mesh at locations that intersect another mesh object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mo</strong> (<em>PyLaGriT mesh object</em>) &#8211; Mesh object to intersect with current mesh object to determine where to refine</li>
<li><strong>level</strong> (<em>int</em>) &#8211; max level of refinement</li>
<li><strong>imt</strong> (<em>int</em>) &#8211; Value to assign to imt (LaGriT material type attribute)</li>
<li><strong>prd_choice</strong> (<em>int</em>) &#8211; directions of refinement</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.resetpts_itp">
<code class="descname">resetpts_itp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.resetpts_itp" title="Permalink to this definition">¶</a></dt>
<dd><p>set node type from connectivity of mesh</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.rmpoint_compress">
<code class="descname">rmpoint_compress</code><span class="sig-paren">(</span><em>filter_bool=False</em>, <em>resetpts_itp=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.rmpoint_compress" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all marked nodes and correct the itet array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>resetpts_itp</strong> (<em>bool</em>) &#8211; set node type from connectivity of mesh</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.rotateln">
<code class="descname">rotateln</code><span class="sig-paren">(</span><em>coord1, coord2, theta, center=[0, 0, 0], copy=False, stride=(1, 0, 0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.rotateln" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates a point distribution (specified by ifirst,ilast,istride) about a line. 
The copy option allows the user to make a copy of the original points as well 
as the rotated points, while copy=False just keeps the rotated points themselves. 
The line of rotation defined by coord1 and coord2 needs to be defined such that 
the endpoints extend beyond the point distribution being rotated. theta (in degrees) 
is the angle of rotation whose positive direction is determined by the right-hand-rule, 
that is, if the thumb of your right hand points in the direction of the line 
(1 to 2), then your fingers will curl in the direction of rotation. center is the point 
where the line can be shifted to before rotation takes place. 
If the copy option is chosen, the new points will have only coordinate values 
(xic, yic, zic); no values will be set for any other mesh object attribute for these points.
Note:  The end points of the  line segment must extend well beyond the point set being rotated.</p>
<dl class="docutils">
<dt>Example 1:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylagrit</span> <span class="k">import</span> <span class="n">PyLaGriT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">10.1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lg</span> <span class="o">=</span> <span class="n">PyLaGriT</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mqua</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">gridder</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">elem_type</span><span class="o">=</span><span class="s1">&#39;hex&#39;</span><span class="p">,</span><span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mqua</span><span class="o">.</span><span class="n">rotateln</span><span class="p">([</span><span class="n">mqua</span><span class="o">.</span><span class="n">xmin</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="n">mqua</span><span class="o">.</span><span class="n">xmax</span><span class="o">+</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mqua</span><span class="o">.</span><span class="n">dump_exo</span><span class="p">(</span><span class="s1">&#39;rotated.exo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mqua</span><span class="o">.</span><span class="n">dump_ats_xml</span><span class="p">(</span><span class="s1">&#39;rotated.xml&#39;</span><span class="p">,</span><span class="s1">&#39;rotated.exo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mqua</span><span class="o">.</span><span class="n">paraview</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt>Example 2:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylagrit</span> <span class="k">import</span> <span class="n">PyLaGriT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">10.1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#z = [0,1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lg</span> <span class="o">=</span> <span class="n">PyLaGriT</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layer</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">gridder</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">elem_type</span><span class="o">=</span><span class="s1">&#39;quad&#39;</span><span class="p">,</span><span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layer</span><span class="o">.</span><span class="n">rotateln</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">ymin</span><span class="o">-</span><span class="mf">0.10</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">ymax</span><span class="o">+</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layer</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;tmp_lay_top.inp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Layer depths?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#           1   2   3    4    5    6    7   8    9   10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layers</span> <span class="o">=</span> <span class="p">[</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">addnum</span> <span class="o">=</span> <span class="p">[</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#matnum = [2]*len(layers)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matnum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layer_interfaces</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtop</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tmp_lay_top.inp 1,9&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#stack_files.append(&#39;tmp_lay_peat_bot.inp 1,33&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">li</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">layer_interfaces</span><span class="p">,</span><span class="n">matnum</span><span class="p">,</span><span class="n">addnum</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">layer</span><span class="o">.</span><span class="n">math</span><span class="p">(</span><span class="s1">&#39;sub&#39;</span><span class="p">,</span><span class="n">li</span><span class="p">,</span><span class="s1">&#39;zic&#39;</span><span class="p">,</span><span class="n">cmosrc</span><span class="o">=</span><span class="n">mtop</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">stack_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;tmp_lay&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.inp &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">layer</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;tmp_lay&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.inp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layer</span><span class="o">.</span><span class="n">math</span><span class="p">(</span><span class="s1">&#39;sub&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;zic&#39;</span><span class="p">,</span><span class="n">cmosrc</span><span class="o">=</span><span class="n">mtop</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#layer.setatt(&#39;zic&#39;,-2.)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layer</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;tmp_lay_bot.inp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;tmp_lay_bot.inp 2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack_files</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create stacked layer mesh and fill</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span><span class="o">.</span><span class="n">stack_layers</span><span class="p">(</span><span class="s1">&#39;avs&#39;</span><span class="p">,</span><span class="n">stack_files</span><span class="p">,</span><span class="n">flip_opt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack_hex</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">stack_fill</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack_hex</span><span class="o">.</span><span class="n">dump_exo</span><span class="p">(</span><span class="s1">&#39;rotated.exo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack_hex</span><span class="o">.</span><span class="n">dump_ats_xml</span><span class="p">(</span><span class="s1">&#39;rotated.xml&#39;</span><span class="p">,</span><span class="s1">&#39;rotated.exo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack_hex</span><span class="o">.</span><span class="n">paraview</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.subset">
<code class="descname">subset</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em>, <em>geom='xyz'</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Mesh Object Subset</p>
<p>Creates a new mesh object that contains only a geometric subset defined
by mins and maxs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mins</strong> &#8211; Coordinate of one of the shape&#8217;s defining points.
xyz (Cartesian):   (x1, y1, z1); 
rtz (Cylindrical): (radius1, theta1, z1);
rtp (Spherical):   (radius1, theta1, phi1);</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate of one of the shape&#8217;s defining points.
xyz (Cartesian):   (x2, y2, z2); 
rtz (Cylindrical): (radius2, theta2, z2);
rtp (Spherical):   (radius2, theta2, phi2);</li>
<li><strong>geom</strong> (<em>str</em>) &#8211; Type of geometric shape: &#8216;xyz&#8217; (spherical), 
&#8216;rtz&#8217; (cylindrical), &#8216;rtp&#8217; (spherical)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Typep mins:</th><td class="field-body"><p class="first last">tuple(int, int, int)</p>
</td>
</tr>
</tbody>
</table>
<p>Returns: MO object</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#To use pylagrit, import the module.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pylagrit</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#Start the lagrit session.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lg</span> <span class="o">=</span> <span class="n">pylagrit</span><span class="o">.</span><span class="n">PyLaGriT</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#Create a mesh object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span><span class="o">.</span><span class="n">createpts_brick_xyz</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#Take the subset from (3,3,3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span><span class="o">.</span><span class="n">subset</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.subset_rtp">
<code class="descname">subset_rtp</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.subset_rtp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Spherical MO Subset</p>
<p>Creates a new mesh object that contains only a spherical subset 
defined by mins and maxs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius1, theta1, and phi1.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius2, theta2, and phi2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.subset_rtz">
<code class="descname">subset_rtz</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.subset_rtz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Cylindrical MO Subset</p>
<p>Creates a new mesh object that contains only a cylindrical subset 
defined by mins and maxs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius1, theta1, and z1.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Defines radius2, theta2, and z2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.subset_xyz">
<code class="descname">subset_xyz</code><span class="sig-paren">(</span><em>mins</em>, <em>maxs</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.subset_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Tetrehedral MO Subset</p>
<p>Creates a new mesh object that contains only a tetrehedral subset 
defined by mins and maxs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mins</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate point of 1 of the tetrahedral&#8217;s corners.</li>
<li><strong>maxs</strong> (<em>tuple(int, int, int)</em>) &#8211; Coordinate point of 1 of the tetrahedral&#8217;s corners.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: MO object</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.trans">
<code class="descname">trans</code><span class="sig-paren">(</span><em>xold</em>, <em>xnew</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate mesh according to old coordinates &#8220;xold&#8221; to new coordinates &#8220;xnew&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xold</strong> (<em>tuple(float,float,float)</em>) &#8211; old position</li>
<li><strong>xnew</strong> (<em>tuple(float,float,float)</em>) &#8211; new position</li>
<li><strong>stride</strong> (<em>tuple(int,int,int)</em>) &#8211; tuple of (first, last, stride) of points</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.tri_mesh_output_prep">
<code class="descname">tri_mesh_output_prep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.tri_mesh_output_prep" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare tri mesh for output, remove dudded points,
ensure delaunay volumes, etc.
Combination of lagrit commands:
filter/1 0 0
rmpoint/compress
recon/1
resetpts/itp</p>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.triangulate">
<code class="descname">triangulate</code><span class="sig-paren">(</span><em>order='clockwise'</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>triangulate will take an ordered set of nodes in the current 2d mesh object that define a perimeter of a polygon and create a trangulation of the polygon.  The nodes are assumed to lie in the xy plane; the z coordinate is ignored.  No checks are performed to verify that the nodes define a legal perimeter (i.e. that segments of the perimeter do not cross).  The code will connect the last node to the first node to complete the perimeter.</p>
<p>This code support triangulation of self-intersecting polygons (polygon with holes), assuming that the order of the nodes are correct. Moreover the connectivity of the polyline must also be defined correctly. No checks are made.</p>
<dl class="docutils">
<dt>One disadvantage of the algorithm for triangulating self-intersecting polygons is that it does not always work. For example, if the holes have complicated shapes, with many concave vertices, the code might fail. In this case, the user may try to rotate the order of the nodes: </dt>
<dd><dl class="first docutils">
<dt>NODE_ID: </dt>
<dd>1 -&gt; 2 
2 -&gt; 3 
... 
N -&gt; 1</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param order:</th><td class="field-body">direction of point ordering</td>
</tr>
<tr class="field-even field"><th class="field-name">type order:</th><td class="field-body">string</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylagrit</span> <span class="k">import</span> <span class="n">PyLaGriT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create pylagrit object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lg</span> <span class="o">=</span> <span class="n">PyLaGriT</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define polygon points in clockwise direction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and create tri mesh object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="p">[</span><span class="mf">2200.0</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="p">[</span><span class="mf">2200.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motri</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">tri_mo_from_polyline</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Triangulate polygon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motri</span><span class="o">.</span><span class="n">triangulate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motri</span><span class="o">.</span><span class="n">setatt</span><span class="p">(</span><span class="s1">&#39;imt&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motri</span><span class="o">.</span><span class="n">setatt</span><span class="p">(</span><span class="s1">&#39;itetclr&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># refine mesh with successively smaller edge length constraints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edge_length</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">250</span><span class="p">,</span><span class="mi">125</span><span class="p">,</span><span class="mi">75</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_length</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">motri</span><span class="o">.</span><span class="n">resetpts_itp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">motri</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">refine_option</span><span class="o">=</span><span class="s1">&#39;rivara&#39;</span><span class="p">,</span><span class="n">refine_type</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">inclusive_flag</span><span class="o">=</span><span class="s1">&#39;inclusive&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">motri</span><span class="o">.</span><span class="n">smooth</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">motri</span><span class="o">.</span><span class="n">recon</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># provide additional smoothing after the last refine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">motri</span><span class="o">.</span><span class="n">smooth</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">motri</span><span class="o">.</span><span class="n">recon</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create delaunay mesh and clean up</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motri</span><span class="o">.</span><span class="n">tri_mesh_output_prep</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># dump fehm files</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motri</span><span class="o">.</span><span class="n">dump_fehm</span><span class="p">(</span><span class="s1">&#39;nk_mesh00&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motri</span><span class="o">.</span><span class="n">paraview</span><span class="p">()</span> 
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.upscale">
<code class="descname">upscale</code><span class="sig-paren">(</span><em>method</em>, <em>attsink</em>, <em>cmosrc</em>, <em>attsrc=None</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>boundary_choice=None</em>, <em>keepatt=False</em>, <em>set_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.upscale" title="Permalink to this definition">¶</a></dt>
<dd><p>The upscale command is used to interpolate attribute values from nodes of a fine source mesh to node
attributes of a coarse sink mesh. The subroutine finds nodes of the fine source mesh within the Voronoi
cell of every node in the coarser sink mesh. Nodes on cell boundaries are assigned to two or more sink
nodes. Then the attributes of all the source nodes within a source node&#8217;s cell are upscaled into a
single value based on the chosen method. Mesh elements and connectivity are ignored and only node
values are used to upscale values on to the sink mesh nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> (<em>str</em>) &#8211; Type of upscaling: sum, min, max, and averages ariave, harave, geoave</li>
<li><strong>attsink</strong> (<em>str</em>) &#8211; attribute sink</li>
<li><strong>cmosrc</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; PyLaGriT mesh object source</li>
<li><strong>attsrc</strong> (<em>str</em>) &#8211; attribute src, defaults to name of attsink</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
<li><strong>boundary_choice</strong> (<em>str</em>) &#8211; method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes: single, divide, or multiple</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.upscale_ariave">
<code class="descname">upscale_ariave</code><span class="sig-paren">(</span><em>attsink</em>, <em>cmosrc</em>, <em>attsrc=None</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>boundary_choice=None</em>, <em>keepatt=False</em>, <em>set_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.upscale_ariave" title="Permalink to this definition">¶</a></dt>
<dd><p>Upscale using arithmetic average of cmosrc points within Voronoi volumes of current mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attsink</strong> (<em>str</em>) &#8211; attribute sink</li>
<li><strong>cmosrc</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; PyLaGriT mesh object source</li>
<li><strong>attsrc</strong> (<em>str</em>) &#8211; attribute src</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
<li><strong>boundary_choice</strong> (<em>str</em>) &#8211; method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes: single, divide, or multiple</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.upscale_geoave">
<code class="descname">upscale_geoave</code><span class="sig-paren">(</span><em>attsink</em>, <em>cmosrc</em>, <em>attsrc=None</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>boundary_choice=None</em>, <em>keepatt=False</em>, <em>set_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.upscale_geoave" title="Permalink to this definition">¶</a></dt>
<dd><p>Upscale using geometric average of cmosrc points within Voronoi volumes of current mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attsink</strong> (<em>str</em>) &#8211; attribute sink</li>
<li><strong>cmosrc</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; PyLaGriT mesh object source</li>
<li><strong>attsrc</strong> (<em>str</em>) &#8211; attribute src</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
<li><strong>boundary_choice</strong> (<em>str</em>) &#8211; method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes: single, divide, or multiple</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.upscale_harave">
<code class="descname">upscale_harave</code><span class="sig-paren">(</span><em>attsink</em>, <em>cmosrc</em>, <em>attsrc=None</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>boundary_choice=None</em>, <em>keepatt=False</em>, <em>set_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.upscale_harave" title="Permalink to this definition">¶</a></dt>
<dd><p>Upscale using harmonic average of cmosrc points within Voronoi volumes of current mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attsink</strong> (<em>str</em>) &#8211; attribute sink</li>
<li><strong>cmosrc</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; PyLaGriT mesh object source</li>
<li><strong>attsrc</strong> (<em>str</em>) &#8211; attribute src</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
<li><strong>boundary_choice</strong> (<em>str</em>) &#8211; method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes: single, divide, or multiple</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.upscale_max">
<code class="descname">upscale_max</code><span class="sig-paren">(</span><em>attsink</em>, <em>cmosrc</em>, <em>attsrc=None</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>boundary_choice=None</em>, <em>keepatt=False</em>, <em>set_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.upscale_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Upscale using maximum of cmosrc points within Voronoi volumes of current mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attsink</strong> (<em>str</em>) &#8211; attribute sink</li>
<li><strong>cmosrc</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; PyLaGriT mesh object source</li>
<li><strong>attsrc</strong> (<em>str</em>) &#8211; attribute src</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
<li><strong>boundary_choice</strong> (<em>str</em>) &#8211; method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes: single, divide, or multiple</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.upscale_min">
<code class="descname">upscale_min</code><span class="sig-paren">(</span><em>attsink</em>, <em>cmosrc</em>, <em>attsrc=None</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>boundary_choice=None</em>, <em>keepatt=False</em>, <em>set_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.upscale_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Upscale using minimum of cmosrc points within Voronoi volumes of current mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attsink</strong> (<em>str</em>) &#8211; attribute sink</li>
<li><strong>cmosrc</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; PyLaGriT mesh object source</li>
<li><strong>attsrc</strong> (<em>str</em>) &#8211; attribute src</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
<li><strong>boundary_choice</strong> (<em>str</em>) &#8211; method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes: single, divide, or multiple</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pylagrit.MO.upscale_sum">
<code class="descname">upscale_sum</code><span class="sig-paren">(</span><em>attsink</em>, <em>cmosrc</em>, <em>attsrc=None</em>, <em>stride=(1</em>, <em>0</em>, <em>0)</em>, <em>boundary_choice=None</em>, <em>keepatt=False</em>, <em>set_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pylagrit.MO.upscale_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Upscale using sum of cmosrc points within Voronoi volumes of current mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attsink</strong> (<em>str</em>) &#8211; attribute sink</li>
<li><strong>cmosrc</strong> (<em>PyLaGriT Mesh Object</em>) &#8211; PyLaGriT mesh object source</li>
<li><strong>attsrc</strong> (<em>str</em>) &#8211; attribute src</li>
<li><strong>stride</strong> (<em>tuple(int)</em>) &#8211; tuple of (first, last, stride) of points</li>
<li><strong>boundary_choice</strong> (<em>str</em>) &#8211; method of choice when source nodes are found on the boundary of multiple Voronoi volumes of sink nodes: single, divide, or multiple</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="autodoc.html">Class Documentation</a><ul>
      <li>Previous: <a href="autodoc_pylagrit.html" title="previous chapter">PyLaGriT</a></li>
      <li>Next: <a href="autodoc_pset.html" title="next chapter">Mesh Object</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="sources/autodoc_mo.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Dylan R. Harp.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.8</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="sources/autodoc_mo.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>